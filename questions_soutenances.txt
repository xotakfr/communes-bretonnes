1. Le rayon d'un graphe consiste en la plus petite excentricité du graphe sachant que l'excentricité de chaque sommet correspond au maximum des distances entre ce sommet et les autres sommets du graphe. Ce paramètre de graphe a pour sens de nous indiquer la ou les communes de la région bretagne qui sont le plus proche de toutes les autres communes et donc la ou les communes de la région bretagne qui sont les plus centrales à celle-ci. On pourra en déterminer que ces communes centrales ont une plus forte chance d'être des communes importantes de par leur position géographique.
2. Nous avons implémenté trois indicateurs de centralité soit la centralité d'intermédiarité, la centralité de degré et la centralité de proximité. Ceux-ci permettent, dans l'ordre indiqué, de découvrir les arrêtes les plus importantes du graphe, les sommets les plus importants du graphe et les sommets les plus proches d'un sous-ensemble de sommets tel que, par exemple, le sous-ensemble des communes ayant une gare.
3. Les algorithmes de Kruskal, de Prim et de Steiner (ainsi qu'une implémentation de l'algortihme de Dijkstra) peuvent être utilisés pour obtenir un arbre couvrant de poids minimal sur le réseau ferré BreizhGo. Sachant qu'un arbre couvrant de poids minimal est un graphe partiel du graphe principal, on peut interpréter le résultat pour la région Bretagne comme le graphe partiel qui relierait l'ensemble des gares du réseau ferré BreizghGo pour un poids minimum soit de distance, soit de coût et soit de tout autre paramètre. Le choix du paramètre dépend d'elle.
4. Il est possible d'aider la région bretagne dans ce choix en utilisant et en calculant la centralité de proximité des communes de Rennes et de Pontivy en les plaçant dans un sous-graphe des communes existants qui ne contient que les communes qui desservent le réseau ferré de la région bretagne et les deux villes concernées. La ville ayant le résultat le plus proche de 1 sera celle la mieux reliée par le train et donc celle où il faut mieux installer son siège social.
5. Il y a de nombreux outils que nous aurions pu utiliser comme Excel, facile à utiliser pour des analyses simples mais limité pour des analyses avancées. Mais nous avons plutôt opté pour le language de programmation Python et ses librairies telles que geopandas, numpy et matplotlib. Python est excellent pour les statistiques et la visualisation. Il a l’avantage d’être polyvalent et intégré avec d'autres outils de science des données, surtout lorsqu'il s'agit d'intégrer des analyses dans des applications. En revanche, la liberté que ce language accorde peut faire en sorte que certaines opérations deviennent plus lourdes d’où la nécessité d’optimiser son code ce qui est une contrainte en soi-même.
6. Voici des types graphiques que l’on connait : Histogrammes : Pour distribuer des données, Graphiques linéaires : Pour les tendances temporelles, Graphiques à barres : Pour des comparaisons de catégories, Graphiques circulaires : Pour des distributions de parts, Nuages de points : Pour les relations entre deux variables, Heatmaps : Pour des matrices de corrélation. Dans le cadre de notre application, nous ne proposons pas certaines de ces visualisations...
7. L'étude séparée de deux variables peut être suffisante dans le cas où s'est deux variables n'ont pas de rapport entre elles cependant si celles-ci s'avèrent avoir un rapport alors il est nécessaire d'effectuer des analyses bivariées. Quelques méthodes de statistiques à deux dimensions inclues la création d'un tableau de contingence, le calcul du rapport de corrélation et le calcul de détermination. Savoir pour quels types de données et comment faire tout ça. Voir notre rendu de statistiques si on avait fait quelque chose d'intéressant.
8. Nous n'avons pas utilisé des séries temporelles pour l'étude des données de cette SAE car celles-ci n'y sont pas adaptées. Tout d'abord, il faut savoir que très peu de données fournies ont un rapport avec la temporalité (on pourrait penser au taux d'inflation annuel ou à l'évolution des données annuelles d'une commune). Cependant, ces données sont présentes en trop faibles quantités pour obtenir des séries temporelles intéressantes dont les données sont significatives puisqu'elles s'étendent sur un total de 4 ans avec seulement une valeur par année. Une série temporelle serait plus intéressante et pertinente à étudier pour des données journalières qui s'étendent sur un moins une année et si possible sur un minimum de cinq ans ce qui n'est pas le cas d'aucunes de nos données.
9. Initialement, les tables provenues des fichiers csv qui nous étaient proposées n'étaient pas satisfaisantes du fait qu'elles contenaient beaucoup de redondance des données et certaines qui pouvaient être rassemblées sous la même table étaient séparées. Par exemple, les fichiers prixParCommune.csv/depensesCulturellesParCommunes.csv/tauxInflationParAn traitent tous de données annuelles qui pourraient être rassemblées en une même table. Par résoudre ce problème, nous avons effectué une base de données relationelle rassemblant les données ayant un rapport entre elles puis nous avons fait en sorte que cette base de données relationelle respecte la forme normale de Boyce-Codd (BCNF ou 3.5NF) afin de garantir l'intégrité de nos données et la réduction de la redondance de celles-ci.
10. Trois méchanismes principaux existent afin de garantir la reconstitution de telles informations. Tout d'abord, je vais vous parler des clés primaires et des clés étrangères qui consiste à assurer une intégrité référentielle de nos données en reliant nos enrengistrements entre différentes tables (par exemple, il sera impossible d'avoir deux fois la même clé primaire donc redondance sur la même table ou avoir plusieurs fois le même enrengistrement dans différentes tables). Autrement, il y a les vues qui sont des méchanismes permettant de créer des ensembles de données en combinant les données de plusieurs tables afin de, par exemple, retrouver les données égarées d'un même enrengistrement étalées sur plusieurs tables.
11. Ces objets sont ce qu'on appelle les vues, une vue consiste en une requête SQL stockée sous la même forme qu'une table et dont les données peuvent être sélectionnées pour être réutilisées. Elles peuvent contenir n'importe quel type de résultat du moment que celui-ci est le même que renvoyé par la requête SQL. Dans le cadre de notre projet, des vues ont été utilisées pour les méthodes que nous avons créées pour nos rendus en statistiques ainsi que nos rendus. 
12. L'administration d'une base de données avec un SGBD comme MySQL se déroule à l'aide de la mise en place d'utilisateurs ainsi que de privilèges et de rôles qu'on attribuent à ces utilisateurs. Par exemple, si je souhaite administrer une base de données ouverte à plusieurs utilisateurs à l'échelle nationale alors il est nécessaire de faire une distinction entre les utilisateurs qui ne modifie pas et modifie cette base de données (différentiation entre clients et administrateurs de la BDD), je pourrais donc créer des rôles pour les clients et des rôles pour les administrateurs qui ont des privilèges différents (seulement voir les données pour l'utilsiateur, pouvoir modifier telle ou telle table pour les administrateurs, donner la permission d'attribuer des privilèges à un certain adminsitrateur qui serait alors l'administrateur en chef de la BDD, etc)
13. Un privilège consiste en le droit d'effectuer une action sur une colonne, table ou base de données qu'on attribue à un rôle ou un utilisateur particulier alors qu'un rôle consiste en un ensemble de privilèges qui seront tous également attribués aux utilisateurs a qui appartient ce rôle. Il existe aussi la possibilité qu'un rôle consiste en l'ensemble de sous-rôles, dans ce cas ce rôle aura pour privilèges l'ensemble des privilèges de ses sous-rôles.
14. Une exception est un événement qui occure lors du lancement de notre programme java. Avant de parler de comment les manipulées, il faut comprendre leur fonctionnement. Il faut savoir qu'il existe des exceptions qu'on dit controlées et des exceptions qu'on dit non-controlées (dessiner l'arborescence des exceptions et montrer lesquelles sont lesquelles). De plus, il faut savoir qu'un telle événement doit être capturé dans la méthode où il s'est exécuté ou être propagé à la méthode appelante. Enfin, celles-ci peuvent être manipulée en les générant à l'aide du mot-clé throw new X("message"); Après cela, il faut capturer l'exception (clauses try/catch/finally) ou la laisée se propager dans la méthode appelante. Maintenant, parlons du cadre de la SAE; nous avons effectué la gestion de celles-ci en capturant les exceptions pouvant provoquer un crash de notre application et en générant nos propres exceptions utilisées pour lancer du code alternatif. 
15. Compiler l'application avec le flag -Xlint qui nous donnait plus d'informations sur les erreurs de compilation; utiliser des scénarios; tester l'application "en direct" comme si nous étions des utilisateurs -> faire le plus de tentatives chaotiques (injections SQL, données erronées, etc)
16. Une interface est une collection de méthodes abstraites (sans implémentation) que les classes implémentantes doivent définir. Elle permet de définir des comportements communs que différentes classes peuvent implémenter. Contrairement à une classe abstraite qui peut avoir des méthodes avec implémentation, des méthodes à implémentées et des champs, l’interface ne peut pas avoir d'état (champs) et ne peut définir que des méthodes abstraites. Dans le cadre de notre projet, nous avons définis beaucoup d'interfaces dans les situations où nous avions du code à factorisé/obligatoirement implémenté certaines méthodes
17. Pour notre rendu de R2.01, nous avons décidé de stocker les données annuelles relatives aux communes dans des objets appelés DonneesAnnuelles où chaque attribut de l'objet est l'une de ces données annuelles. Nous n'utilisons pas d'instances de la classe commune pour pouvoir y accéder cependant nous avons fait en sorte que les instances de DonneesAnnuelles contiennent une instance Annee et une instance Commune légitime comme attribut. Ainsi, il est possible de récupérer les données annuelles d'une commune en connaisant 1) la commune concernée et 2) l'année concernée à l'aide de méthodes de recherche que nous avons misent en place.
18. Les éléments mis en place pour faciliter la maintenabilité de notre code de SAE est la mise en place de noms de méthodes explicites et normés ainsi que la mise en place presque systématique de documentation java ou/et python pour chaque classes et chaque méthodes. Des documents HTML générés à l'aide de la javadoc pourrait donc être utilisés pour qu'un développeur n'ayant pas connaissance de notre code puisse modifier et compléter notre application. Autrement, des exemples imagés des intéractions entre les objets/instances pourrait aider, par exemple des diagrammes de classe/de séquences.
19. Un diagramme de classe représente la structure statique d'un système, cela inclue les classes, leurs attributs, les méthodes et les relations. Un diagramme de séquence montre les interactions dynamiques entre objets selon un ordre chronologique d'exécution, illustrant ainsi l'échange de messages pour réaliser des scénarios. ( Partie pour la région Bretagne à faire)
20. En JavaFX, les principaux événements à gérer sont, entre autres les événements de souris (MouseEvent), de clavier (KeyEvent) et d'action (ActionEvent). ( Trouver la partie pour le code)
21. JavaFX utilise différents types de conteneurs de mise en page pour structurer les éléments graphiques, comme HBox pour une organisation horizontale, VBox pour une organisation verticale, GridPane pour une organisation en grille et BorderPane pour une organisation en cinq zones (haut, bas, gauche, droite, centre). ( Trouver la partie du code)
22. Le modèle MVC (Modèle-Vue-Contrôleur) sépare les données (Modèle), la présentation (Vue) et la logique de contrôle (Contrôleur) dans une application. Il permet une meilleure organisation et gestion du code en simplifiant la maintenance, la réutilisation des éléments et la collaboration au sein d'une équipe de développeurs. ( Trouver la partie du code)
23. La structure de base d'une IHM JavaFX débute avec une classe principale qui hérite de de la classe Application de javafx et met en œuvre la méthode start(). Dans cette approche, le Stage est l'entité qui affiche la fenêtre principale et contient une Scene avec un nœud racine (Parent) tel qu'un StackPane ou un conteneur similaire. Des boutons et d'autres éléments graphiques sont insérés dans ce conteneur principal, puis la scène est connectée au stage principal en utilisant primaryStage.setScene(scene). Finalement, on appelle primaryStage.show() pour afficher l'interface utilisateur. ( Trouver la partie du code)
24. En JavaFX, il existe deux méthodes principales pour créer une vue : l'une consiste à utiliser FXML pour décrire la structure de l'interface utilisateur de manière déclarative, et l'autre consiste à créer et configurer directement en Java les éléments graphiques. Nous avons principalement opté pour l'utilisation de FXML dans le projet en raison de la vitesse de conception conséquente associée à cette méthode, sa relative facilité d'utilisation et la séparation claire entre la vue, le modèle et le contrôleur (impossible de mettre des données du contrôleur ou du modèle dans la vue puisqu'on utilise un logiciel qui est purement axé sur la vue).
25. Il faut séparer la partie d'accès aux données et le contrôleur pour travailler sur une  architecture facile à entretenir où les chances de conflits sont faibles. Quant au classes DAO, elles encapsulent les détails de la base de données ce qui permet au contrôleur de se concentrer sur la logique d'utilisation. Cela rend plus facile la réutilisation du code, simplifie les tests unitaires et diminue la dépendance de l'application envers des technologies spécifiques, comme JDBC. En effet, il suffirait simplement de modifier la partie du programme qui effectue la connexion lorsqu'on change de technologie au lieu de modifier l'ensemble du programme.
26. En Java, pour gérer les fichiers, les classes principales sont File pour la représentation des fichiers, FileReader et FileWriter pour la lecture et l'écriture de fichiers texte, et FileInputStream et FileOutputStream pour les fichiers binaires. La variation se trouve dans le type de données : les fichiers texte comprennent des caractères lisibles par les humains, alors que les fichiers binaires renferment des informations brutes non textuelles. ( Partie pour la région Bretagne à faire) A ENTIEREMENT REFAIRE MAIS J'AI LA FLEMME CE SOIR
27. En JDBC, le principal problème de sécurité avec createStatement par rapport  à preparedStatement est le risque d’attaques par injection SQL. createStatement exécute directement les requêtes SQL avec les données fournies, offrant ainsi la possibilité à un attaquant d'injecter du code malveillant. Alors que preparedStatement sécurise l'exécution des requêtes en les pré-compilant et en liant les paramètres de manière sûre, ce qui protège contre les attaques par injection et renforce la sécurité de l'application. Donner un exemple de createStatement et prepareStatement est recommandé.
28. Nous avons organisé la gestion du temps entre les différents rendus et tâches de la "grande SAE" Communes Bretonnes en utilisant un diagramme de Gantt implémenter sur Notion. Il nous a facilité la visualisation des échéances, l'assignation des tâches à chaque membre de l'équipe et le suivi en temps réel de l'avancement du projet en tenant compte des contraintes pour respecter les délais. Les réunions fréquentes, qu'elles soient écrites ou orales, ont permis de revoir les priorités et de changer le calendrier en fonction de l'avancement et des difficultés rencontrées. Quant à la gestion des fichiers, nous avons utilisé un dépôt github que nous mettons à jour régulièrement.
29. Les trois principaux défis de la gestion de projet sont le temps, le coût et la qualité. Pour la SAE Communes Bretonnes, nous avons respecté les délais en faisant les rendus dans les temps, tout cela en adaptant la qualité du projet au temps alloué malgré certaines de nos espérances initiales pour assurer une démo réussie, pour les coûts, il n’y en a pas eu de pars le cadre du projet. <-------------- merci chatgpt là, flemme ce soir aussi
30. Un chef de projet informatique doit organiser, suivre la mise en œuvre et la finalisation des projets en tenant compte le temps impartis et le budget alloué à la réalisation de ce dernier, tout en garantissant la qualité du produit livré. La gestion du temps et des ressources, la communication et la résolution de problèmes sont trois compétences fondamentales. Pendant la réalisation du projet citoyen, on a organisé notre temps pour respecter les délais, les échanges pour nous coordonner notamment au travers du Notion, et la résolution de difficultés pour adapter notre stratégie aux problèmes qui se présentaient à nous. <------ bon ça va mais je reprendrais les compétences citées en R2.10 pour un chef de projet au lieu de "bullshit" un peu
31. Notion est une application centralisée qui facilite la gestion de projets en regroupant tout ce qui est documents, listes de tâches, calendriers et notes de réunion dans un même espace en ligne. Elle rend la gestion de projet plus efficace et organisée en permettant la collaboration en temps réel avec des fonctionnalités de partage d'édition et des intégrations avec des outils répandus comme Google Drive et Slack.